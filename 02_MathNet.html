<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Prof. Dr. Juanjo Manjarín" />


<title>Mathematical Description of Networks</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/journal.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  { color: #cccccc; background-color: #303030; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ffcfaf; } /* Alert */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #dca3a3; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.ch { color: #dca3a3; } /* Char */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.co { color: #7f9f7f; } /* Comment */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.do { color: #7f9f7f; } /* Documentation */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.er { color: #c3bf9f; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #c0bed1; } /* Float */
code span.fu { color: #efef8f; } /* Function */
code span.im { } /* Import */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
code span.kw { color: #f0dfaf; } /* Keyword */
code span.op { color: #f0efd0; } /* Operator */
code span.ot { color: #efef8f; } /* Other */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.ss { color: #cc9393; } /* SpecialString */
code span.st { color: #cc9393; } /* String */
code span.va { } /* Variable */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 61px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h2 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h3 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h4 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h5 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h6 {
  padding-top: 66px;
  margin-top: -66px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Social Media Analytics</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Social Media Analytics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Unit I</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="01_NetworkData.html">Networks and their Data Sets</a>
        </li>
        <li>
          <a href="02_MathNet.html">Mathematical Description of Networks</a>
        </li>
        <li>
          <a href="03_Measures.html">Measures in Networks</a>
        </li>
        <li>
          <a href="04_RBasics.html">Basics of `igraph`</a>
        </li>
        <li>
          <a href="05_Ex_Unit_I_solutions.html">Exercises</a>
        </li>
      </ul>
    </li>
    <li class="divider"></li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Unit II</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="06_RNets.html">Random Networks</a>
        </li>
        <li>
          <a href="07_SFNets.html">Scale-Free Networks</a>
        </li>
        <li>
          <a href="08_PANets.html">Preferential Attachment Networks</a>
        </li>
        <li>
          <a href="09_NetModels.html">Modelling Networks in R</a>
        </li>
        <li>
          <a href="10_Ex_Unit_II.html">Exercises</a>
        </li>
      </ul>
    </li>
    <li class="divider"></li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Unit III</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="DegCor.html">Degree Correlation</a>
        </li>
        <li>
          <a href="Assort.html">Assortativity</a>
        </li>
        <li>
          <a href="ComNet.html">Introduction to Communities</a>
        </li>
        <li>
          <a href="MAAlg.html">Machine Learning Algorithms in R</a>
        </li>
        <li>
          <a href="Ex_Unit_III.html">Exercises</a>
        </li>
      </ul>
    </li>
    <li class="divider"></li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Unit IV</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="SprePhen.html">Spreading Phenomena</a>
        </li>
        <li>
          <a href="CEMod.html">Classical Epidemics Models</a>
        </li>
        <li>
          <a href="NetEpi.html">Network Epidemics</a>
        </li>
        <li>
          <a href="NetDif.html">Network Diffusion</a>
        </li>
        <li>
          <a href="Ex_Unit_IV.html">Exercises</a>
        </li>
      </ul>
    </li>
    <li class="divider"></li>
  </ul>
</li>
<li>
  <a href="IntroR.html">R Course</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Mathematical Description of Networks</h1>
<h4 class="author">Prof. Dr. Juanjo Manjarín</h4>

</div>

<div id="TOC">
<ul>
<li><a href="#formal-definitions"><span class="toc-section-number">1</span> Formal Definitions</a></li>
<li><a href="#degree-and-degree-distribution"><span class="toc-section-number">2</span> Degree and Degree Distribution</a><ul>
<li><a href="#degree"><span class="toc-section-number">2.1</span> Degree</a></li>
<li><a href="#average-degree"><span class="toc-section-number">2.2</span> Average Degree</a></li>
<li><a href="#degree-distribution"><span class="toc-section-number">2.3</span> Degree Distribution</a></li>
</ul></li>
<li><a href="#ajacency-matrix"><span class="toc-section-number">3</span> Ajacency Matrix</a><ul>
<li><a href="#complete-networks"><span class="toc-section-number">3.1</span> Complete Networks</a></li>
<li><a href="#weighted-networks"><span class="toc-section-number">3.2</span> Weighted Networks</a></li>
<li><a href="#adjacency-and-edge-lists"><span class="toc-section-number">3.3</span> Adjacency and Edge Lists</a></li>
</ul></li>
<li><a href="#connectivity-in-graphs"><span class="toc-section-number">4</span> Connectivity in Graphs</a><ul>
<li><a href="#paths-and-distances"><span class="toc-section-number">4.1</span> Paths and Distances</a><ul>
<li><a href="#paths-and-shortest-paths"><span class="toc-section-number">4.1.1</span> Paths and Shortest Paths</a></li>
<li><a href="#diameter"><span class="toc-section-number">4.1.2</span> Diameter</a></li>
<li><a href="#distance"><span class="toc-section-number">4.1.3</span> Distance</a></li>
<li><a href="#average-path-length"><span class="toc-section-number">4.1.4</span> Average Path Length</a></li>
</ul></li>
<li><a href="#density"><span class="toc-section-number">4.2</span> Density</a></li>
<li><a href="#connectedness"><span class="toc-section-number">4.3</span> Connectedness</a><ul>
<li><a href="#components"><span class="toc-section-number">4.3.1</span> Components</a></li>
<li><a href="#types-of-connected-components"><span class="toc-section-number">4.3.2</span> Types of Connected Components</a></li>
<li><a href="#cutpoints-and-bridges"><span class="toc-section-number">4.3.3</span> Cutpoints and Bridges</a></li>
</ul></li>
</ul></li>
</ul>
</div>

<hr />
<p>This document is devoted to the mathematical description of a network by means of the <strong>Adjacency Matrix</strong>, also known as <strong>Sociomatrix</strong>. This document needs the <code>igraph</code> package loaded, so take a look at the document <a href="Basics.html">Basics of <code>igraph</code></a> to see how to install it in order to follow the explanations.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(igraph, <span class="dt">warn.conflicts=</span><span class="ot">FALSE</span>, <span class="dt">quietly=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p>We are going to use the same <strong>undirected graph</strong> we define in the <a href="Basics.html">Basics of <code>igraph</code></a> document, so let’s generate it (do not worry about the meaning of the functions used to define the graphs, they are explained in the same document)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">g &lt;-<span class="st"> </span><span class="kw">graph.formula</span>(<span class="dv">1-2</span>, <span class="dv">2-3</span>, <span class="dv">1-5</span>, <span class="dv">3-4</span>, <span class="dv">5-7</span>, <span class="dv">4-6</span>, <span class="dv">1-6</span>, <span class="dv">3-6</span>, <span class="dv">2-7</span>, <span class="dv">2-4</span>)</a></code></pre></div>
<p>Also, for later purposes, let’s define the <strong>digraph</strong> (directed graph)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">di_g &lt;-<span class="st"> </span><span class="kw">graph.formula</span>(<span class="dv">1</span><span class="op">-+</span><span class="dv">2</span>, <span class="dv">2</span><span class="op">+-</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">+-</span><span class="dv">5</span>, <span class="dv">3</span><span class="op">+-</span><span class="dv">4</span>, <span class="dv">5</span><span class="op">-+</span><span class="dv">7</span>, <span class="dv">4</span><span class="op">+-</span><span class="dv">6</span>, <span class="dv">1</span><span class="op">-+</span><span class="dv">6</span>, <span class="dv">3</span><span class="op">+-</span><span class="dv">6</span>, <span class="dv">2</span><span class="op">-+</span><span class="dv">7</span>, <span class="dv">2</span><span class="op">-+</span><span class="dv">4</span>)</a></code></pre></div>
<!-- formal definitions -->
<div id="formal-definitions" class="section level1">
<h1><span class="header-section-number">1</span> Formal Definitions</h1>
<p>Let’s fix the notation we will use along the course:</p>
<ul>
<li>Given a set of <strong>edges</strong>, <span class="math inline">\(E\)</span>, and a set of <strong>vertices</strong> <span class="math inline">\(V\)</span>, A <strong>graph</strong> is a pair <span class="math inline">\(G(E,V)\)</span></li>
<li>Denoting as <span class="math inline">\(N\)</span> the number of vertices, i.e. the <strong>order of the graph</strong>, we can write the set of <strong>vertices</strong> as</li>
</ul>
<p><span class="math display">\[\begin{equation}
 V = \{ v_1, v_2\dots v_N\}
 \end{equation}\]</span></p>
<p>The order of the graph can be found as</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">gorder</span>(g)</a></code></pre></div>
<pre><code>## [1] 7</code></pre>
<ul>
<li>Denoting as <span class="math inline">\(L\)</span> the number of edges, i.e. the <strong>size of the graph</strong>, we can write the set of <strong>edges</strong> as</li>
</ul>
<p><span class="math display">\[\begin{equation}
 E = \{ e_1, e_2\dots e_L\}
 \end{equation}\]</span></p>
<p>The size of the graph can be found as</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">gsize</span>(g)</a></code></pre></div>
<pre><code>## [1] 10</code></pre>
<p>In this notation, note that an edge between vertices 1 and 2 cen be written as <span class="math inline">\(e(v_1, v_2)\)</span>, and a <strong>loop</strong>, or <strong>self-link</strong>, which is an edge beginning and ending on the same vertex as <span class="math inline">\(e(v_1, v_1)\)</span>.</p>
<ul>
<li>The <strong>neighborhood</strong> of a vertex, <span class="math inline">\(N(v_i)\)</span>, is the set of all the vertices connected to that vertex. If we have a digraph, then there is an <strong>outgoing neighborhood</strong>, as the set of all the outgoing vertices from a given vertex, and an <strong>ingoing neighborhood</strong>, as the set of all the incoming vertices to a given vertex.</li>
</ul>
<p>The neighborhood can be found as</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">neighborhood</span>(g)</a></code></pre></div>
<pre><code>## [[1]]
## + 4/7 vertices, named, from 4559918:
## [1] 1 2 5 6
## 
## [[2]]
## + 5/7 vertices, named, from 4559918:
## [1] 2 1 3 4 7
## 
## [[3]]
## + 4/7 vertices, named, from 4559918:
## [1] 3 2 4 6
## 
## [[4]]
## + 3/7 vertices, named, from 4559918:
## [1] 5 1 7
## 
## [[5]]
## + 4/7 vertices, named, from 4559918:
## [1] 4 2 3 6
## 
## [[6]]
## + 3/7 vertices, named, from 4559918:
## [1] 7 2 5
## 
## [[7]]
## + 4/7 vertices, named, from 4559918:
## [1] 6 1 3 4</code></pre>
<p>later you will see that this output is rather much like the <a href="#adjacency-and-edge-lists">edge list or the adjacency list</a>.</p>
<p><a href="#">Back to top</a></p>
<hr />
<!-- degree -->
</div>
<div id="degree-and-degree-distribution" class="section level1">
<h1><span class="header-section-number">2</span> Degree and Degree Distribution</h1>
<p>The degree is one of the most basic measures in any network analysis, not just from a descriptive perspective, but most of the network models are modelling precisely the degree distribution.</p>
<div id="degree" class="section level2">
<h2><span class="header-section-number">2.1</span> Degree</h2>
<p>The size of the neighborhood of a vertex is known as the degree, then the <strong>degree</strong> is the number of edges connected to a vertex. We will denote the degree of the vertex <span class="math inline">\(v_i\)</span> as <span class="math inline">\(k_i\)</span>, then we can easily see that, for un undirected graph, the size is given</p>
<p><span class="math display">\[\begin{equation}
L = \frac{1}{2}\sum_{i=1}^N k_i 
\end{equation}\]</span></p>
<p>where the division by 2 comes from the fact that each link connects two different nodes of the network. In <code>igraph</code> we have the <code>degree()</code> function that finds the degree of each node in the network</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">degree</span>(g)</a></code></pre></div>
<pre><code>## 1 2 3 5 4 7 6 
## 3 4 3 2 3 2 3</code></pre>
<p>However, if the graph is a digraph, we talk about <strong>indegree</strong>, <span class="math inline">\(k_i^{in}\)</span>, as the number of incomming links to the node (<em>followers</em>, for example) and of <strong>outdegree</strong>, <span class="math inline">\(k_i^{out}\)</span>, as the number of outgoing links from the node (<em>friends</em>, for example). In this case, the size of the network is</p>
<p><span class="math display">\[\begin{equation}
L = \sum_{i=1}^N k_i^{in} = \sum_{i=1}^N k_i^{out}
\end{equation}\]</span></p>
<p>Now, to use <code>degree()</code> we must specify the mode, “in” or “out”, to be computed, for example</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">degree</span>(di_g, <span class="dt">mode =</span> <span class="st">&quot;in&quot;</span>)</a></code></pre></div>
<pre><code>## 1 2 3 5 4 7 6 
## 1 2 2 0 2 2 1</code></pre>
<p>Take into account that the output of these functions is a named vector, something really helpful since the output is not ordered by the node label, a number in this case, so be careful in reading this and the previous outputs.</p>
<p><a href="#">Back to top</a></p>
</div>
<div id="average-degree" class="section level2">
<h2><span class="header-section-number">2.2</span> Average Degree</h2>
<p>An important quantity in a network is the <strong>average degree</strong>, which can be directly computed as the arithmetic mean of the degrees in a network. For an undirected graph we can find it as</p>
<p><span class="math display">\[\begin{equation}
&lt;k&gt; = \frac{1}{N}\sum_{i=1}^N k_i = \frac{2L}{N}
\end{equation}\]</span></p>
<p>while for a digraph we will find an <strong>average indegree</strong> and an <strong>average outdegree</strong>, which can be found as</p>
<p><span class="math display">\[\begin{equation}
&lt;k^{in}&gt; = \frac{1}{N}\sum_{i=1}^N k_i^{in} = \frac{L}{N}
\end{equation}\]</span></p>
<p>These quantitites will appear in different ways in the models of networks, as soon as they are can be used, since, remember, that an average is <em>meaningful</em> as long as the frequency/probability distribution it comes from is symmetric, in this case the <strong>degree distribution</strong>.</p>
<p>Note that there is no pre-built in R function to explicitely compute the average degree. It would be, however, rather absurd since we just need the usual <code>mean()</code> function</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">mean</span>(<span class="kw">degree</span>(g))</a></code></pre></div>
<pre><code>## [1] 2.857143</code></pre>
<p><a href="#">Back to top</a></p>
</div>
<div id="degree-distribution" class="section level2">
<h2><span class="header-section-number">2.3</span> Degree Distribution</h2>
<p>The <strong>degree distribution</strong> is the probability distribution of the degrees in a network, i.e. it returns the probability that a given node has a particular degree. At this point we can only define it in terms of the classical relative frequency, then</p>
<p><span class="math display">\[\begin{equation}
p_k = \frac{N_k}{N}
\end{equation}\]</span></p>
<p>where <span class="math inline">\(N_k\)</span> is the number of nodes with degree <span class="math inline">\(k\)</span>. With the usual constraint</p>
<p><span class="math display">\[\begin{equation}
\sum_{k = 1}^\infty p_k = 1
\end{equation}\]</span></p>
<p>In our graph <em>g</em>, the degree (total frequency) distribution is</p>
<p><br></p>
<table>
<thead>
<tr class="header">
<th align="center">degree</th>
<th align="center"><span class="math inline">\(n\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr class="odd">
<td align="center">4</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>then the degree distribution is just</p>
<p><br></p>
<table>
<thead>
<tr class="header">
<th align="center">degree</th>
<th align="center"><span class="math inline">\(p_k\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center">2/7 <span class="math inline">\(\approx\)</span> 0.29</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="center">3/7 = <span class="math inline">\(\approx\)</span> 0.57</td>
</tr>
<tr class="odd">
<td align="center">4</td>
<td align="center">1/7 = <span class="math inline">\(\approx\)</span> 0.14</td>
</tr>
<tr class="even">
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>In R we can use the <code>degree.distribution()</code> function of <code>igraph</code> to determine the degree distribution, then we find</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">degree.distribution</span>(g)</a></code></pre></div>
<pre><code>## [1] 0.0000000 0.0000000 0.2857143 0.5714286 0.1428571</code></pre>
<p>exactly as before.</p>
<p>Once we have the degree distribution, we can use it in the usual way to find expected values, then the average degree (<strong>expected degree</strong>, in this context) would be</p>
<p><span class="math display">\[\begin{equation}
&lt;k&gt; = \sum_{k = 0}^\infty k\cdot p_k
\end{equation}\]</span></p>
<p>this just means that if two nodes are connected, then we write a 1 in the corresponding matrix entrance.</p>
<p><a href="#">Back to top</a></p>
<hr />
<!-- adjacency matrix -->
</div>
</div>
<div id="ajacency-matrix" class="section level1">
<h1><span class="header-section-number">3</span> Ajacency Matrix</h1>
<p>The <strong>Adjacency Matrix</strong>, or <strong>Sociomatrix</strong>, <span class="math inline">\(A_ij\)</span>, is the mathematical representation of all the links in a network, then we can define it as</p>
<p><span class="math display">\[\begin{equation}
A_{ij} = \left\{\begin{array}{ll} 1, &amp; \text{if } e(v_i,v_j)\in E \\ 0, &amp; \text{otherwise} \end{array} \right.
\end{equation}\]</span></p>
<p>which basically means that it is a square matrix with dimensions given by the order of the network and such that has a 1 whenever two nodes are linked and a 0 otherwise.</p>
<p>In the case of an undirected graph it will always be an <span class="math inline">\(N\times N\)</span> symmetric matrix such that the per-row or per-column sums return the degree of each node</p>
<p><span class="math display">\[\begin{equation}
k_m = \sum_{i = 1}^N A_{im} = \sum_{j = 1}^N A_{mj}
\end{equation}\]</span></p>
<p>For a digraph, it is not symmetric and then we must consider the rows and columns as the directions from and to other nodes. In this sense, it is a bit arbitrary to decide along which direction we write what, but let’s keep the following criterium:</p>
<ul>
<li>Along the <strong>rows</strong> we will find the <strong>outgoing</strong> links</li>
<li>Along the <strong>columns</strong> we will find the <strong>incomming</strong> links</li>
</ul>
<p>then summing along rows and columns will give us the <strong>outdegree</strong> and the <strong>indegree</strong> respectively.</p>
<p><span class="math display">\[\begin{equation}
k_m^{in} = \sum_{j=1}^N A_{mj},\qquad k_m^{out} = \sum_{i=1}^N A_{im}
\end{equation}\]</span></p>
<p>Obtaining the adjacency matrix in <code>igraph</code> is straightforward, since we have the <code>get.adjacency()</code> function for it. The result <em>dgCMatrix</em>, the standard data type for sparse numeric matrices. Then we can just use it directly on the graph</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">get.adjacency</span>(g)</a></code></pre></div>
<pre><code>## 7 x 7 sparse Matrix of class &quot;dgCMatrix&quot;
##   1 2 3 5 4 7 6
## 1 . 1 . 1 . . 1
## 2 1 . 1 . 1 1 .
## 3 . 1 . . 1 . 1
## 5 1 . . . . 1 .
## 4 . 1 1 . . . 1
## 7 . 1 . 1 . . .
## 6 1 . 1 . 1 . .</code></pre>
<p>and exactly the same for the digraph</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">get.adjacency</span>(di_g)</a></code></pre></div>
<pre><code>## 7 x 7 sparse Matrix of class &quot;dgCMatrix&quot;
##   1 2 3 5 4 7 6
## 1 . 1 . . . . 1
## 2 . . . . 1 1 .
## 3 . 1 . . . . .
## 5 1 . . . . 1 .
## 4 . . 1 . . . .
## 7 . . . . . . .
## 6 . . 1 . 1 . .</code></pre>
<p>As a side note, it should be clear that you will only find non-zero elements in the diagonal of the matrix if and only if there are loops in the network.</p>
<p><a href="#">Back to top</a></p>
<div id="complete-networks" class="section level2">
<h2><span class="header-section-number">3.1</span> Complete Networks</h2>
<p>What is the maximum number of possible links in a network? Since we have <span class="math inline">\(N\)</span> nodes and a link is just a tie bewteen any two of them, we can immediately see that for <strong>undirected graphs</strong></p>
<p><span class="math display">\[\begin{equation}
L_{max}^{un} = \begin{pmatrix}N \\ 2\end{pmatrix} = \frac{N\cdot (N-1)}{2}
\end{equation}\]</span></p>
<p>while for <strong>directed graphs</strong> we have</p>
<p><span class="math display">\[\begin{equation}
L_{max}^{dir} = N\cdot (N-1)
\end{equation}\]</span></p>
<p>since each node can go in two different directions.</p>
<p>A graph whose number of edges is precisely <span class="math inline">\(L_{max}\)</span> is known as a <strong>complete graph</strong>, often called <strong>cliques</strong>.</p>
<p><br></p>
<div class="figure" style="text-align: center">
<img src="02_MathNet_files/figure-html/tikz-ex-1.png" alt="Fig.: A Complete Graph with 16 nodes using a circular layout" width="30%" />
<p class="caption">
Fig.: A Complete Graph with 16 nodes using a circular layout
</p>
</div>
<p><br></p>
<p>In the language of adjacency matrix, and assuming no loops, a clique is described as a matrix with everywhere 1s (except the diagonal)</p>
<p><span class="math display">\[\begin{equation}
A_{clique} = \begin{pmatrix} 0 &amp; 1 &amp; 1 &amp; \dots &amp; 1 \\ 1 &amp; 0 &amp; 1 &amp; \dots &amp; 1 \\ \vdots &amp; &amp; \ddots &amp; &amp; \vdots \\ 1 &amp; 1 &amp; 1 &amp; \dots &amp; 0  \end{pmatrix}
\end{equation}\]</span></p>
<p>Of course, in real networks, cliques do not appear but in small groups, since real networks are sparse. Take a look at the following table with real data of three different networks</p>
<p><br></p>
<table>
<thead>
<tr class="header">
<th align="center">Network</th>
<th align="center">Nodes</th>
<th align="center">Links</th>
<th align="center"><span class="math inline">\(N\)</span></th>
<th align="center"><span class="math inline">\(L_{max}\)</span></th>
<th align="center"><span class="math inline">\(L\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">Citation Network</td>
<td align="center">Papers</td>
<td align="center">Citations</td>
<td align="center">449,673</td>
<td align="center">101,102,678,628</td>
<td align="center">4,689,479</td>
</tr>
<tr class="even">
<td align="center">Actor Network</td>
<td align="center">Actors</td>
<td align="center">Co-acting</td>
<td align="center">702,388</td>
<td align="center">246,674,100,078</td>
<td align="center">29,397,908</td>
</tr>
<tr class="odd">
<td align="center">Protein Interactions</td>
<td align="center">Proteins</td>
<td align="center">Binding Interactions</td>
<td align="center">2,018</td>
<td align="center">2,035,153</td>
<td align="center">2,930</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>From the table it is clear that even though some networks do have a high number of links (almost 30M for the actor network), it is still very low compared to the maximum number they could actually have.</p>
<p><a href="#">Back to top</a></p>
</div>
<div id="weighted-networks" class="section level2">
<h2><span class="header-section-number">3.2</span> Weighted Networks</h2>
<p>Let’s now consider the case of <strong>weighted graphs</strong>, where the links have an attribute named <em>weight</em>. In real cases this is a definite property of the type of link between nodes, for example, if the nodes are cities, these weights may represent the distance between them; if the nodes are email users, weights can be the total or the relative number of emails sent.</p>
<p>Let’s add a weight to the graphs we have already defined, see that since we do not want to overwrite the data, first we make a copy of the graph and then add the weights as an attribute to the new graph. These weights receive the name <code>mails</code> in an attempt to give them the meaning of the number of emails interchanged between the different actors, assumed to be the nodes, then</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">mails &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">we_g &lt;-<span class="st"> </span>g</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="kw">E</span>(we_g)<span class="op">$</span>weight &lt;-<span class="st"> </span>mails</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">we_dig &lt;-<span class="st"> </span>di_g</a>
<a class="sourceLine" id="cb22-7" data-line-number="7"><span class="kw">E</span>(we_dig)<span class="op">$</span>weight &lt;-<span class="st"> </span>mails</a></code></pre></div>
<p>Now the adjacency matrix is not a (1,0)-matrix anymore, but the inputs are the weights, and then as a general definition we have</p>
<p><span class="math display">\[\begin{equation}
A_{ij} = \left\{\begin{array}{ll} w_{ij}, &amp; \text{if } e(v_i,v_j)\in E \\ 0, &amp; \text{otherwise} \end{array} \right.
\end{equation}\]</span></p>
<p>where <span class="math inline">\(w_{ij}\)</span> is the weight of the edge connecting nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>.</p>
<p>To obtain the adjacency matrix in <code>igraph</code>, we have to add the argument weight as an attribute, then the call of the function becomes</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">get.adjacency</span>(we_g, <span class="dt">attr =</span> <span class="st">&quot;weight&quot;</span>)</a></code></pre></div>
<pre><code>## 7 x 7 sparse Matrix of class &quot;dgCMatrix&quot;
##   1 2 3 5 4 7 6
## 1 . 2 . 3 . . 1
## 2 2 . 1 . 3 3 .
## 3 . 1 . . 2 . 1
## 5 3 . . . . 4 .
## 4 . 3 2 . . . 5
## 7 . 3 . 4 . . .
## 6 1 . 1 . 5 . .</code></pre>
<p>from where we see the weights as the inputs of the matrix, as expected.</p>
<p><a href="#">Back to top</a></p>
</div>
<div id="adjacency-and-edge-lists" class="section level2">
<h2><span class="header-section-number">3.3</span> Adjacency and Edge Lists</h2>
<p>Sometimes we can give not the adjacency matrix but the edge list and the adjacency list. These are just side representations that may be as useful as, for example, the stem-and-leaf diagram in statistics.</p>
<p>To get the <strong>adjacency list</strong> we use</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">get.adjlist</span>(g)</a></code></pre></div>
<pre><code>## $`1`
## + 3/7 vertices, named, from 4559918:
## [1] 2 5 6
## 
## $`2`
## + 4/7 vertices, named, from 4559918:
## [1] 1 3 4 7
## 
## $`3`
## + 3/7 vertices, named, from 4559918:
## [1] 2 4 6
## 
## $`5`
## + 2/7 vertices, named, from 4559918:
## [1] 1 7
## 
## $`4`
## + 3/7 vertices, named, from 4559918:
## [1] 2 3 6
## 
## $`7`
## + 2/7 vertices, named, from 4559918:
## [1] 2 5
## 
## $`6`
## + 3/7 vertices, named, from 4559918:
## [1] 1 3 4</code></pre>
<p>from where we obtain the vertices that are adjacent (connected) to each other vertex. Then, for example, we see that <span class="math inline">\(v_2&lt;\)</span> is connected with <span class="math inline">\(V_1\)</span>, <span class="math inline">\(v_3\)</span>, <span class="math inline">\(v_4\)</span> and <span class="math inline">\(v_7\)</span> (remember that the order is not given by the label in this case)</p>
<p>The edge list gives the same information but may be more useful when we have digraphs, since it returns the sign of the arrow in the connection. We obtain it as</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">get.adjedgelist</span>(g)</a></code></pre></div>
<pre><code>## $`1`
## + 3/10 edges from 4559918 (vertex names):
## [1] 1--2 1--5 1--6
## 
## $`2`
## + 4/10 edges from 4559918 (vertex names):
## [1] 1--2 2--3 2--4 2--7
## 
## $`3`
## + 3/10 edges from 4559918 (vertex names):
## [1] 2--3 3--4 3--6
## 
## $`5`
## + 2/10 edges from 4559918 (vertex names):
## [1] 1--5 5--7
## 
## $`4`
## + 3/10 edges from 4559918 (vertex names):
## [1] 2--4 3--4 4--6
## 
## $`7`
## + 2/10 edges from 4559918 (vertex names):
## [1] 2--7 5--7
## 
## $`6`
## + 3/10 edges from 4559918 (vertex names):
## [1] 1--6 3--6 4--6</code></pre>
<p><a href="#">Back to top</a></p>
<hr />
<!-- connectivity in graphs -->
</div>
</div>
<div id="connectivity-in-graphs" class="section level1">
<h1><span class="header-section-number">4</span> Connectivity in Graphs</h1>
<p>The connectivity in a network speaks about how are the nodes tied: distance between nodes, shortest path, density of edges and the connected components of the graph, are different parts of the analysis we can perform from this perspective.</p>
<!-- paths and distances -->
<div id="paths-and-distances" class="section level2">
<h2><span class="header-section-number">4.1</span> Paths and Distances</h2>
<p>Let’s first define two ideas:</p>
<ul>
<li>Two nodes are <strong>Adjacent</strong> if they are connected by an edge</li>
<li>Two edges are <strong>Incident</strong> if they share an endpoint</li>
</ul>
<p>Let’s now see the different paths and quantities we can obtain from a graph</p>
<p><br></p>
<table>
<tr>
<th>
Graph Path
</th>
<th>
Explanation
</th>
</tr>
<br>
<tr style="border-bottom:1px solid black">
<td colspan="100%">
</td>
</tr>
<tr>
<td>
<br> <img src="02_MathNet_files/figure-html/unnamed-chunk-17-1.png" width="60%" style="display: block; margin: auto;" /> <br>
</td>
<td>
<p>In this graph we can identify the path from node <span class="math inline">\(E\)</span> to node <span class="math inline">\(F\)</span> as</p>
<p><span class="math display">\[\begin{equation}
e_1(E, A)\,e_2(A,B)\,e_3(B,D)\,e_4(D,F)
\end{equation}\]</span></p>
This type of path is known as <strong>open walk</strong> (it would be <strong>closed</strong> if the starting and ending nodes were the same). In the same sense it is a <strong>trail</strong> since all the nodes traversed are different.
</td>
</tr>
<br>
<tr style="border-bottom:1px solid black">
<td colspan="100%">
</td>
</tr>
<tr>
<td>
<br> <img src="02_MathNet_files/figure-html/unnamed-chunk-18-1.png" width="60%" style="display: block; margin: auto;" /> <br>
</td>
<td>
<p>A closed path is one with the same starting and ending points, is a <strong>cycle</strong>, as the one</p>
<p><span class="math display">\[\begin{equation}
e_1(A, B)\,e_2(B,D)\,e_3(D,C)\,e_4(C,A)
\end{equation}\]</span></p>
<p>A graph has a <strong>Hamiltonian cycle</strong> if it has a cycle that visits each node of network only once. The cycle is <strong>Eulerian</strong> if all the edges are traversed but each is only once.</p>
A graph with no cycles is known as <strong>tree</strong>, if it is connected or as <strong>forest</strong> if it is disconnected.
</td>
</tr>
<tr style="border-bottom:1px solid black">
<td colspan="100%">
</td>
</tr>
<tr>
<td>
<br> <img src="02_MathNet_files/figure-html/unnamed-chunk-19-1.png" width="60%" style="display: block; margin: auto;" /> <br>
</td>
<td>
<p><br> We call <strong>distance</strong> to the number of edges traverse in going from one node to another. In this sense we denote as the <strong>shortest path</strong>, or <strong>geodesic path</strong>, to the path with the smallest number of traversed nodes in going from one node to another.</p>
<p>In our graph, in going from node <span class="math inline">\(E\)</span> to node <span class="math inline">\(F\)</span> we have 2 different shortest paths:</p>
<p><span class="math display">\[\begin{equation}
e_1(E, A)\,e_2(A,B)\,e_3(B,D)\,e_4(D,F)
\end{equation}\]</span></p>
<p>and</p>
<p><span class="math display">\[\begin{equation}
e_1(E, A)\,e_2(A,C)\,e_3(C,D)\,e_4(D,F)
\end{equation}\]</span></p>
<p>both with a length of <span class="math inline">\(4\)</span>. The distance of the longest shortest path is known as the <strong>diameter of the network</strong> <br></p>
</td>
</tr>
<tr style="border-bottom:1px solid black">
<td colspan="100%">
</td>
</tr>
<tr>
<td>
<br> <img src="02_MathNet_files/figure-html/unnamed-chunk-20-1.png" width="60%" style="display: block; margin: auto;" /> <br>
</td>
<td>
<p>To find the <strong>Average Path Length</strong>, so the average distance from any node in the network to any other node. We find it as</p>
<p><span class="math display">\[\begin{equation}
&lt;d&gt; = \frac{1}{L_{max}}\sum_{i,j = 1}^N d_{i,j}
\end{equation}\]</span></p>
<p>where <span class="math inline">\(L_{max}\)</span> depends on the graph being directed or undirected.</p>
</td>
</tr>
<tr style="border-bottom:1px solid black">
<td colspan="100%">
</td>
</tr>
</table>
<p><br></p>
<p>The graph in the table can be defined as follows</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1">paths_graph &lt;-<span class="st"> </span><span class="kw">graph.formula</span>(<span class="st">&quot;A&quot;</span><span class="op">-</span><span class="st">&quot;B&quot;</span>, <span class="st">&quot;A&quot;</span><span class="op">-</span><span class="st">&quot;C&quot;</span>, <span class="st">&quot;A&quot;</span><span class="op">-</span><span class="st">&quot;E&quot;</span>, <span class="st">&quot;B&quot;</span><span class="op">-</span><span class="st">&quot;D&quot;</span>, <span class="st">&quot;C&quot;</span><span class="op">-</span><span class="st">&quot;D&quot;</span>, <span class="st">&quot;D&quot;</span><span class="op">-</span><span class="st">&quot;F&quot;</span>)</a></code></pre></div>
<p>Let’s use <code>igraph</code> to determine the previous quantities</p>
<p><a href="#">Back to top</a></p>
<!-- paths and shortest paths -->
<div id="paths-and-shortest-paths" class="section level3">
<h3><span class="header-section-number">4.1.1</span> Paths and Shortest Paths</h3>
<p>We have a different functions to use here: <code>all_simple_paths()</code>, <code>all_shortest_paths()</code> or <code>shortest_paths()</code> are some of them, which return a list with all the corresponding types of paths.</p>
<p>In order to find the shortest paths from <span class="math inline">\(E\)</span> to <span class="math inline">\(F\)</span> we use</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">all_shortest_paths</span>(paths_graph, <span class="dt">from =</span> <span class="st">&quot;E&quot;</span>, <span class="dt">to =</span> <span class="st">&quot;F&quot;</span>)</a></code></pre></div>
<pre><code>## $res
## $res[[1]]
## + 5/6 vertices, named, from 559ad65:
## [1] E A B D F
## 
## $res[[2]]
## + 5/6 vertices, named, from 559ad65:
## [1] E A C D F
## 
## 
## $nrgeo
## [1] 1 1 1 1 2 2</code></pre>
<p>of course, we may not add the “to” argument, and then it finds all the shortests paths from the starting node. In any case, we see that there are two different shortest paths of length 4 between <span class="math inline">\(E\)</span> and <span class="math inline">\(F\)</span>.</p>
<p>There is a general theorem that states that the inputs of the powers of the adjacency matrix give the number of paths of length the power between the nodes of a network.</p>
<p>In this case, for example, we know that we can only reach <span class="math inline">\(F\)</span> from <span class="math inline">\(E\)</span> using a path of length 4 (4 edges) and that there are two different paths, then if we compute the fourth power of the adjacency matrix, the value <span class="math inline">\(A^4_{EF}\)</span> should be 2, let’s see it</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1">A &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">get.adjacency</span>(paths_graph))</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">A <span class="op">%*%</span><span class="st"> </span>A <span class="op">%*%</span><span class="st"> </span>A <span class="op">%*%</span><span class="st"> </span>A</a></code></pre></div>
<pre><code>##    A  B  C E  D F
## A 13  0  0 0 12 0
## B  0 10 10 5  0 5
## C  0 10 10 5  0 5
## E  0  5  5 3  0 2
## D 12  0  0 0 13 0
## F  0  5  5 2  0 3</code></pre>
<p>as expected, we find that <span class="math inline">\(A^4_{EF} = 2\)</span>.</p>
<p><a href="#">Back to top</a></p>
<!-- diameter -->
</div>
<div id="diameter" class="section level3">
<h3><span class="header-section-number">4.1.2</span> Diameter</h3>
<p>Since we need to know <em>all</em> the shortest paths, we may apply the previous function to all the nodes and then find the longest among them. However, we can also use the <code>diameter()</code> function as</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">diameter</span>(paths_graph)</a></code></pre></div>
<pre><code>## [1] 4</code></pre>
<p><a href="#">Back to top</a></p>
<!-- distance -->
</div>
<div id="distance" class="section level3">
<h3><span class="header-section-number">4.1.3</span> Distance</h3>
<p>To find all the distances we use the <code>distances()</code> function, which returns a symmetric matrix with the steps from one node to any other</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">distances</span>(paths_graph)</a></code></pre></div>
<pre><code>##   A B C E D F
## A 0 1 1 1 2 3
## B 1 0 2 2 1 2
## C 1 2 0 2 1 2
## E 1 2 2 0 3 4
## D 2 1 1 3 0 1
## F 3 2 2 4 1 0</code></pre>
<p>If we read the data for node <span class="math inline">\(A\)</span>, the matrix says that it is one edge away from nodes <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> and <span class="math inline">\(E\)</span>, two edges aways from node <span class="math inline">\(D\)</span> and three away from node <span class="math inline">\(F\)</span>. That this is actually the case can be immediately seen from the graph in the table.</p>
<p>If we want the <strong>distance distribution</strong> we can use the <code>distance_table()</code> function as</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">distance_table</span>(paths_graph, <span class="dt">directed =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code>## $res
## [1] 6 6 2 1
## 
## $unconnected
## [1] 0</code></pre>
<p>This output means that there are 6 one-edge connections, 6 two-edges connections, 2 three-edges connections and 1 four-edges connection. Which is exactly what we have if we count the values in the distances matrix using only the upper or lower triangle values (for undirected graphs).</p>
<p><a href="#">Back to top</a></p>
<!-- average path length -->
</div>
<div id="average-path-length" class="section level3">
<h3><span class="header-section-number">4.1.4</span> Average Path Length</h3>
<p>Using the formula seen above we can manually compute the average path as</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1">dij =<span class="st"> </span><span class="kw">distance_table</span>(paths_graph, <span class="dt">directed =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2">N =<span class="st"> </span><span class="kw">gorder</span>(paths_graph)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">nij =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(dij<span class="op">$</span>res)</a>
<a class="sourceLine" id="cb40-4" data-line-number="4"></a>
<a class="sourceLine" id="cb40-5" data-line-number="5">av_d =<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(dij<span class="op">$</span>res <span class="op">*</span><span class="st"> </span>nij)<span class="op">/</span>(N<span class="op">*</span>(N<span class="dv">-1</span>))</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">av_d</a></code></pre></div>
<pre><code>## [1] 1.866667</code></pre>
<p>so and average length of 1.867. Fortunatelly there is a couple of functions we may use <code>average.path.length()</code> and <code>mean_distance()</code></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">average.path.length</span>(paths_graph) <span class="op">==</span><span class="st"> </span><span class="kw">mean_distance</span>(paths_graph)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">mean_distance</span>(paths_graph)</a></code></pre></div>
<pre><code>## [1] 1.866667</code></pre>
<p>which give us the same result as before.</p>
<p>This Average Path Length tell us what is the average number of edges bewteen any two different nodes of a network, essentially the equivalent to the famous <strong>six-degrees</strong> of separation!</p>
<p><a href="#">Back to top</a></p>
<!-- density -->
</div>
</div>
<div id="density" class="section level2">
<h2><span class="header-section-number">4.2</span> Density</h2>
<p>We define the density of edges in a network as the ratio of the actual size divided by the maximum possible number of ties, then for <strong>undirected graphs</strong> we have</p>
<p><span class="math display">\[\begin{equation}
D^{un} = \frac{L}{L_{max}} = \frac{2L}{N(N-1)}
\end{equation}\]</span></p>
<p>while for <strong>directed graphs</strong> we have</p>
<p><span class="math display">\[\begin{equation}
D^{dir} = \frac{L}{L_{max}} = \frac{L}{N(N-1)}
\end{equation}\]</span></p>
<p>In <code>igraph</code> we use the function <code>edge_density()</code> directly applied to the graph, there is no need to specify if it is directed or undirected. However, note that it has, as default, the option of removing the loops</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">edge_density</span>(g)</a></code></pre></div>
<pre><code>## [1] 0.4761905</code></pre>
<p><a href="#">Back to top</a></p>
<!-- connectedness -->
</div>
<div id="connectedness" class="section level2">
<h2><span class="header-section-number">4.3</span> Connectedness</h2>
<p>A graph is <strong>connected</strong> if there is a path between every pair of nodes in it. Of course, it is <strong>disconnected</strong> otherwise.</p>
<p>To find if a graph is connected we can use simple inspection in the case of few number of nodes or directely pass it to the <code>is_connected()</code> function. In the case of the graph in the table</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">is_connected</span>(paths_graph)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p><a href="#">Back to top</a></p>
<!-- components -->
<div id="components" class="section level3">
<h3><span class="header-section-number">4.3.1</span> Components</h3>
<p>The <strong>components</strong> of a graph are all the connected subgraphs we may find in it. We can identify them with <code>component_distribution()</code>. If we use the graph from the table we find</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">component_distribution</span>(paths_graph)</a></code></pre></div>
<pre><code>## [1] 0 0 0 0 0 0 1</code></pre>
<p>which means that there is one single component made out of 6 six nodes. We can find more information from the <code>components()</code> function:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="kw">components</span>(paths_graph, <span class="st">&quot;strong&quot;</span>)</a></code></pre></div>
<pre><code>## $membership
## A B C E D F 
## 1 1 1 1 1 1 
## 
## $csize
## [1] 6
## 
## $no
## [1] 1</code></pre>
<p>where we use the argument <strong>weak</strong> or <strong>strong</strong> as defined right below. The information given is that all the nodes belong to the same cluster, which is of size 6.</p>
<p><a href="#">Back to top</a></p>
<!-- weak and strong -->
</div>
<div id="types-of-connected-components" class="section level3">
<h3><span class="header-section-number">4.3.2</span> Types of Connected Components</h3>
<p>In digraphs due to the directionalities of the network it may be the case that some nodes cannot be reached from others or that the reachability is not bidirectional, for example, then we denote as</p>
<ul>
<li><strong>Weakly Connected Component</strong>: if there exists a path between any pair of nodes in the network that does not respect the edges directions (this is known as <em>semipath</em>)</li>
<li><strong>Strongly Connected Component</strong>: if there exists a directed path between any pair of nodes in the network</li>
</ul>
<p>there are other types of connected components as <strong>unilateral</strong> or <strong>recursively</strong>, but we leave them out of our study.</p>
<p>Suppose we generate a random digraph with 10 nodes</p>
<p><img src="02_MathNet_files/figure-html/unnamed-chunk-33-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>if we take a look at the graph, the node number 5, cannot be reached by any other node, since it only has outgoing links, therefore, we have two strongly connected components and one weakly connected component, let’s see this from the output of the <code>components()</code> function. If we use the <em>strong</em> argument</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">components</span>(gr, <span class="dt">mode =</span> <span class="st">&quot;strong&quot;</span>)</a></code></pre></div>
<pre><code>## $membership
##  [1] 2 2 2 2 1 2 2 2 2 2
## 
## $csize
## [1] 1 9
## 
## $no
## [1] 2</code></pre>
<p>we obtain two different cluster, one of size 1 and the other of size 9, the only node that belongs to the first component is the node number 5, as expected.</p>
<p>With the <em>weak</em> option</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">components</span>(gr, <span class="dt">mode =</span> <span class="st">&quot;weak&quot;</span>)</a></code></pre></div>
<pre><code>## $membership
##  [1] 1 1 1 1 1 1 1 1 1 1
## 
## $csize
## [1] 10
## 
## $no
## [1] 1</code></pre>
<p>we obtain one single component and so, every node in the network can be reached if we drop the directionality of the edges.</p>
<p><a href="#">Back to top</a></p>
<!-- cutpoints and bridges -->
</div>
<div id="cutpoints-and-bridges" class="section level3">
<h3><span class="header-section-number">4.3.3</span> Cutpoints and Bridges</h3>
<p>The last piece of information we are going to use is the identification of nodes and links that make a network connected. In this sense we have:</p>
<ul>
<li>A node is a <strong>cutpoint</strong> if the number of components of the graph that contains it is smaller than without it. The network below has a cutpoint in node <span class="math inline">\(A\)</span>, since with it, we find one component (left), while without it we find two components (right)</li>
</ul>
<p><img src="02_MathNet_files/figure-html/unnamed-chunk-36-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>In <code>igraph</code> we can use the function <code>articulation.points()</code> to determine which are the cutpoints of our network (named <em>cut</em>)</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="kw">articulation.points</span>(cut)</a></code></pre></div>
<pre><code>## + 2/7 vertices, named, from 5684965:
## [1] E A</code></pre>
<p>In the graph before we have only marked the node <span class="math inline">\(A\)</span>, however, if we remove the node <span class="math inline">\(E\)</span>, we also obtain a network with two components, since the node <span class="math inline">\(G\)</span> will be isolated.</p>
<ul>
<li>An edge is a <strong>bridge</strong> if the number of components of the network that contains it is smaller than without it. In the network below, the edge connecting nodes <span class="math inline">\(A\)</span> and <span class="math inline">\(E\)</span> is a bridge since without it the network has two components (right) while with it it has only one (left).</li>
</ul>
<p><img src="02_MathNet_files/figure-html/unnamed-chunk-38-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>Neither in <code>igraph</code> nor in <code>statnet</code> there is a built-in function to determine the bridges, then you may want to define your own one by checking recursively for all the nodes that if you remove one, the nunmber of components increases.</p>
</div>
</div>
</div>

<footer>
  <div id="rbmvFooter" class="footer">
    <div class="footerContent">
    
    <p>Copyright &copy; 2020 Juanjo Manjarín, IE University. All rights reserved.</p>
    
    </div>
  </div>
</footer>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
